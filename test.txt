// #pragma once



 #include "opencv2/opencv.hpp"
// #include "opencv2/core/ocl.hpp""
// #include "opencv2/core/cuda.hpp""
// #include "opencv2/cudaimgproc.hpp""
// #include "/usr/local/include/opencv2/opencv.hpp"
// #include "/home/jim/Desktop/includes/opencv.hpp"
// #include "opencv2/highgui/highgui.hpp"
// #include "opencv2/imgproc/imgproc.hpp"

#include <iostream>
#include <cstdio>
#include <fstream>
#include <sstream>
#include "ftd2xx.h"
#include<thread>
#include <chrono>
#include<pthread.h>
#include <unistd.h>
#include<ctime>



#include "defines.h"
#include "measure.h"
#include "process_filters.h"
#include "process_other.h"

#include "file_io.h"
#include "maps_and_headers.h"
#include "KeyBoardInput.h"
#include "display_images_text.h"




using namespace std;
using namespace cv;

// Define a pixel opencv
typedef Vec<uint16_t, 3> Pixel_Type;





// Define a pixel  c++
//typedef Point3_<uint16_t> Pixel;
// c++
// typedef std::vector<int> int_vec_t;


/*
struct Image_File_Struct {
   char     File_Name[50];
   int      Gain;
   int      Black_Level;
 //  Vec3w    Color_8bit;
};
*/





void    Fader_Main(int &Current_A_Or_B,  float &Fader_Coef, float &Fade_Direction,  float &Fade_Rate )
{
    Fader_Coef += Fade_Rate * Fade_Direction;
    if(Fader_Coef >= 1.0)
    {
        Fader_Coef = 1.0;
        Current_A_Or_B = Image_A;
    }

    else if(Fader_Coef <= 0.0)
    {
        Fader_Coef = 0.0;
        Current_A_Or_B = Image_B;
    }
}





bool FTDI_On = true;
bool Test_Mode = false;




int main(){

//    pthread_t thread1, thread2;

    // FTDI hardware stuff
	DWORD dwError, dwPriClass;
	DWORD bytes_written;
	FT_HANDLE ftHandle;
	FT_STATUS ftStatus;
	UCHAR Mask = 0xff;
	UCHAR Mode;
	DWORD EventDWord;
	DWORD RxBytes;
	DWORD TxBytes;
	DWORD BytesWritten;
	DWORD BytesReceived;


    time_t time_time;
    struct tm * time_X;


    // array containing sample point locations read from file
    int Sample_Points[SAMPLE_ROWS][SAMPLE_COLS];
    int Num_Of_Samples_Per_Row[SAMPLE_ROWS] ;

    // array containing the panel map
    int Panel_Map[PANEL_MAP_SIZE] ;
    int Panel_Map_W_Gaps[PANEL_MAP_W_GAPS_SIZE] ;

    int Enclosure_Info[NUM_OF_ENCLOSURES][NUM_OF_ENCLOSURE_PARAMETERS];


    // for synchronizing
    uint8_t	 *RxBuffer;
    RxBuffer = new uint8_t [RxBuffer_Size];   // only receives 64 for syncing


// these are for testing only
    uint16_t *Grab_Buffer;
	Grab_Buffer =  new uint16_t [Sculpture_Size_RGB]; //  33408  11136 * 3
    uint16_t *Map_Buffer;
	Map_Buffer =  new uint16_t [Sculpture_Size_RGB];  //  33408  11136 * 3
// this one fills in partial chassis and leaves spaces for enclosure and panel headers
    uint16_t *Map_Buffer_W_Gaps;
	Map_Buffer_W_Gaps =  new uint16_t [Buffer_W_Gaps_Size_RGB];  //  39348  13116 * 3



    uint16_t *Grab_Buffer_RGBW;
	Grab_Buffer_RGBW =  new uint16_t [Sculpture_Size_RGBW];  //  16 bit   4 * 11136    44544
    uint16_t *Map_Buffer_RGBW;
	Map_Buffer_RGBW =  new uint16_t [Sculpture_Size_RGBW];   //  16 bit   4 * 11136    44544
// this one fills in partial chassis and leaves spaces for enclosure and panel headers
    uint16_t *Map_Buffer_W_Gaps_RGBW;
	Map_Buffer_W_Gaps_RGBW =  new uint16_t [Buffer_W_Gaps_Size_RGBW_Extra];   //  16 bit   4 * 13116  52464




    Mat img_in_A, img_in_B;
    Mat img_proc_A, img_proc_B;
    Mat image_proc_sampled_A, image_proc_sampled_B;
    Mat img_proc_u16_A, img_proc_u16_B;

    Mat Mat_Sum;

    Mat Mat_Sum_sampled;

    Mat Mat_Sum_Display;

    Mat text_window;

    Mat upper_LP_window;



    UMat YUV_Gain_A, YUV_Gain_B;

    UMat img_in_A_U, img_in_B_U ;

    UMat    img_proc_A_U, img_proc_B_U ;

    UMat    Mat_Sum_U;





    VideoCapture cap_A, cap_B ;


    // timing measurement stuff
    Prog_Durations Program_Timer;
    Prog_Durations Video_Loop_Timer;
    Prog_Durations Within_Loop_Timer;

    Prog_Durations Temp_Time_Test;

    Prog_Durations New_1;
    Prog_Durations New_2;
    Prog_Durations New_3;
    Prog_Durations New_4;
    Prog_Durations New_5;
    Prog_Durations New_6;
    Prog_Durations New_7;
    Prog_Durations New_8;
    Prog_Durations New_9;
    Prog_Durations New_10;
    Prog_Durations New_11;

    Prog_Durations New_1B;
    Prog_Durations New_2B;
    Prog_Durations New_3B;


    float d1, d2, d3, d4,d5, d6, d7, d8, d9, d10, d11, d12, max_Within_Loop_Timer, max_stored ;

    int cnt;
    int tread;

    int Points_Visible;

    bool Pause_A, Points_Visible_A, Filter_On_Off_A;
    bool Pause_B, Points_Visible_B, Filter_On_Off_B;

    bool F_1p1_A, F_2p2_A,  F_3p3_A, F_4p4_A, Filter_3Taps_On_A ;
    bool F_1p1_B, F_2p2_B,  F_3p3_B, F_4p4_B, Filter_3Taps_On_B ;

    bool Ones2x2_A, Ones3x3_A, Ones4x4_A, Ones5x5_A, Ones6x6_A, Ones7x7_A, Ones_On_A ;
    bool Ones2x2_B, Ones3x3_B, Ones4x4_B, Ones5x5_B, Ones6x6_B, Ones7x7_B, Ones_On_B ;

    bool Reset_All_Filters_A, Reset_All_Filters_B;

    bool Constellation_On = false ;
    bool Lumen_Pulse_Upper_On = false ;

    bool LP_62_On  ;
    bool LP_63_On ;
    bool TRX_On    ;

    bool Seam_Flip;

     bool Video_On;




    bool img_On_A, img_proc_On_A, img_On_B, img_proc_On_B;

	bool Show_Proc_A = true;
	bool Show_Proc_B = true;

    bool Grab  = false ;

    int32_t loopcnt = 0;


    float Gain_A;
    float Black_Level_A ;
    float C_Gain_A ;
    float Luma_Level_A ;

    float Gain_B;
    float Black_Level_B;
    float C_Gain_B;
    float Luma_Level_B;

    float   Downstream_Gain;

    float   Temp_Gain;

    float   Fader_Coef = 1.0 ;
    float   Fade_Rate;
    float   Fade_Direction  = 1.0;
    int     New_Image_Selected = 0;   // finishes after fade limit
    int     Current_A_Or_B = Image_A;   // Fading 0   A 1    B 2
    bool     A_or_B_File_Ext ;

    int     First_Sequence_Image_X = 0;

    int Num_of_Image_Files_Read;


    float Red_62_A, Green_62_A, Blue_62_A;
    float Red_62_B, Green_62_B, Blue_62_B;


    uint8_t Red_62_Combined , Green_62_Combined, Blue_62_Combined ;


    bool    New_Sequenced_Image_Selected;
    int     Current_Sequencer_Selection;
    int     Sequence_Duration_Counter;

    bool New_Keyboard_Image;
    bool New_Sequenced_Image;

    bool    Sequence_On;

    float   Duartion_Mod;

    bool    Stop_Program;


    int64_t Current_Hour;
    int64_t Current_Minute;
    int64_t Current_Second;
    int64_t Time_Turn_On_Total ;  // 8:30 pm
    int64_t Time_Turn_Off_Total ;            // 3  am
    int64_t Time_Current_Total ;
    int64_t Time_Turn_Color_Total ;



    int64_t Turn_On_Time ;
    int64_t Turn_On_Time_Trigger ;
    int64_t Turn_On_Time_Delayed ;


    int64_t Turn_Color_Time ;
    int64_t Turn_Color_Time_Trigger ;
    int64_t Turn_Color_Time_Delayed ;


    int64_t Turn_Off_Time ;
    int64_t Turn_Off_Time_Trigger ;
    int64_t Turn_Off_Time_Delayed ;


    int64_t Hours_On;  // 24 hour
    int64_t Mins_On ;

    int64_t Hours_Color;  // 24 hour
    int64_t Mins_Color ;
    int64_t Night_Color ;

    int64_t  Hours_Off ;
    int64_t Mins_Off ;






     char    Path[200] =  "/Salesforce/BuildingLoaderTop/";
    char    File1[200] ;

    char    CurFile[200];

   	int  New_Image_A = 1;
   	int  New_Image_B = 2;

    char c = -1;

    // initialize the frame buffersw
    img_in_A.create(IMAGE_ROWS,IMAGE_COLS,CV_8UC3);
    img_proc_A.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);  // note tested CV_32FC3 vs CV_16SC3  and they were almost identical
    img_in_B.create(IMAGE_ROWS,IMAGE_COLS,CV_8UC3);
    img_proc_B.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);




    text_window = Mat::zeros( 180, 1024, CV_8UC3 );
    upper_LP_window = Mat::zeros( 70, 256, CV_8UC3 );


    YUV_Gain_A.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);
    YUV_Gain_B.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);

    img_proc_A_U.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);
    img_proc_B_U.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);

    Mat_Sum_U.create(IMAGE_ROWS,IMAGE_COLS,CV_32FC3);



    strcpy(File1, Path);
    strcat(File1, "Maps/GRABMAP4OD.csv");

    tread = Read_Sample_Point_Location_Array(const_cast<char*>(File1),  Sample_Points, Num_Of_Samples_Per_Row);
    printf("READ %d SAMPLE MAP INTS \n", tread);

    strcpy(File1, Path);
    strcat(File1, "Maps/PMO5.csv");
    tread = Read_Map(const_cast<char*>(File1),  Panel_Map_W_Gaps);  // SP6   SP  all points
    printf("READ %d PANEL MAP GAPS INTS \n", tread);

    strcpy(File1, Path);
    strcat(File1, "Maps/Enclosure_Info1.csv");
    tread = Read_Enclosure_Info(const_cast<char*>(File1),   Enclosure_Info);





    // this section is pathetic make better at some point  do with structure or class

    char Image_File_Names[Max_Num_Of_Image_Files][Max_File_Name_Length];
    float Image_Parameters[Max_Num_Of_Image_Files][Max_Num_Of_Image_Parameters];

    char Sequencr_File_Names[Max_Num_Of_Image_Files][Max_File_Name_Length];
    float Sequencer_Parameters[Max_Num_Of_Image_Files][Max_Num_Of_Image_Parameters];



   // strcpy(File1, "Images_Info16-1.csv");
   strcpy(File1, "Images_Info16-MX3.csv");

    tread = Read_Image_Info(const_cast<char*>(File1), Image_File_Names, Image_Parameters );

    for(int p=0; p<tread; p++)
    {
        printf("%s  %.2f %.2f  %.2f      %.1f  %.1f  %.1f \n",   Image_File_Names[p] ,  Image_Parameters[p][Gain_X] , Image_Parameters[p][Black_Level_X], Image_Parameters[p][Chroma_X],
                                    Image_Parameters[p][Red_Val],  Image_Parameters[p][Green_Val], Image_Parameters[p][Blue_Val]);
    }
     printf("\nREAD %d files  \n",  tread);

    Num_of_Image_Files_Read = tread;


    strcpy(File1, "Seq_Temp.csv");  // normal 1
   // strcpy(File1, "Sequencer15c.csv");  // normal 1
    // strcpy(File1, "SequencerCCA2G.csv");
   // strcpy(File1, "Sequencer15b.csv");  // normal 1

   // strcpy(File1, "Sequencer16-1.csv");

    tread = Read_Image_Info(const_cast<char*>(File1), Sequencr_File_Names, Sequencer_Parameters );

    for(int p=0; p<tread; p++)
    {
        printf("%s  %.2f %.2f  %.2f     %.1f  %.1f  %.1f  %.1f  \n",   Sequencr_File_Names[p] ,  Sequencer_Parameters[p][Gain_X] , Sequencer_Parameters[p][Black_Level_X], Sequencer_Parameters[p][Chroma_X],
                                    Sequencer_Parameters[p][Red_Val],  Sequencer_Parameters[p][Green_Val], Sequencer_Parameters[p][Blue_Val],  Sequencer_Parameters[p][Duration]  );
    }
     printf("\nREAD %d files  \n",  tread);

    int Num_of_Sequencer_Image_Files_Read = tread;



    sleep(1);






     // FTDI_Init();  could not get working

    if(FTDI_On)
    {
        ftStatus = FT_Open(0, &ftHandle);
        if(ftStatus != FT_OK)
        {
            // FT_Open failed return;
            printf("FT_Open FAILED! \r\n");
            exit(0);
        }
        else
        {
            printf("\n made it to FTDI initialize \n");
            //set interface into FT245 Synchronous FIFO mode
            Mode = 0x00; //reset mode
            ftStatus = FT_SetBitMode(ftHandle, Mask, Mode);
            Mode = 0x40; //Sync FIFO mode
            ftStatus = FT_SetBitMode(ftHandle, Mask, Mode);
            if (ftStatus != FT_OK) printf("FT_SetBitMode FAILED! \r\n"); // FT_SetBitMode FAILED!
            FT_SetLatencyTimer(ftHandle, 2);
            FT_SetUSBParameters(ftHandle,0x10000, 0x10000);
            FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x0, 0x0);
            FT_Purge(ftHandle, FT_PURGE_RX);

            ftStatus = FT_GetStatus(ftHandle,&RxBytes,&TxBytes,&EventDWord);
            FT_Purge(ftHandle, FT_PURGE_RX);
        }
    }



    strcpy(File1, Path);
    strcat(File1, "Movies/green.mov");
	cap_B.open(File1);


    strcpy(File1, Path);
    strcat(File1, "Movies/brown.mov");
    cap_A.open(File1);


    Video_Loop_Timer.Start_Delay_Timer();
    cnt = 0;


    Points_Visible = 0;

    // temporary keyboard controls
    Pause_A = false;
    Points_Visible_A = false;
    Pause_B = false;
    Points_Visible_B = false;


    img_On_A  = true;
    img_proc_On_A  = true;
    img_On_B  = true;
    img_proc_On_B  = true;



    Reset_All_Filters_A = false;
    Ones3x3_A = true;
    Ones5x5_A = true;
    Ones7x7_A = false;
    Filter_On_Off_A = true;
    Filter_3Taps_On_A = true;
    Ones_On_A = true;

    Reset_All_Filters_B = false;
    Ones3x3_B = true;
    Ones5x5_B = true;
    Ones7x7_B = false;
    Filter_On_Off_B = true;
    Filter_3Taps_On_B = true;
    Ones_On_B = true;


	Gain_A = 0;
	Black_Level_A = 0;
	C_Gain_A = 1.;
	Luma_Level_A = 1.;

	Gain_B = 0;
	Black_Level_B = 0;
	C_Gain_B = 1.;
	Luma_Level_B = 1.;

	Downstream_Gain = .6;


	Red_62_A = 0;
	Green_62_A = 0;
	Blue_62_A = 0;
    Red_62_B = 0;
    Green_62_B = 0;
    Blue_62_B = 0;


    LP_62_On  =true;
    LP_63_On = false;
    TRX_On   = false ;


    Video_On = true;

    Seam_Flip = false;





    Sequence_Duration_Counter = 0;
    Current_Sequencer_Selection = 0;
    New_Sequenced_Image_Selected = false;

    Sequence_On = false;

    bool Sequence_On_Delayed = false;


    Stop_Program = false;


    loopcnt = 0;



    //time_t time_time;
    //struct tm * time_X;




    // Applying time()
    time (&time_time);

    // Using localtime()
    time_X = localtime(&time_time);

    Current_Hour = time_X->tm_hour;
    Current_Minute = time_X->tm_min;
    Current_Second = time_X->tm_sec;

    cout << "Current Day, Date and Time is = " << Current_Hour << " " << Current_Minute; // asctime(time_X);



    Hours_On     = 19; // 20;  // 24 hour  8:30
    Mins_On       = 45;
    Hours_Color   = 01;      // 3 am
    Mins_Color   =  01;
    Hours_Off    = 6;      // 3 am
    Mins_Off     = 15;
    Night_Color = 11; // 11;


    Time_Turn_On_Total =  Hours_On * 3600 + Mins_On * 60  ;  // 8:30 pm
    Time_Turn_Color_Total = Hours_Color * 3600 +  Mins_Color * 60  ;            // assume after midnight
    Time_Turn_Off_Total = Hours_Off * 3600 +  Mins_Off * 60  ;            // assume after midnight


    Time_Current_Total  =  Current_Hour * 3600 + Current_Minute * 60 + Current_Second;


    // if the program is started after the turn on time then the sequencer is enabled
    if(Time_Current_Total >=  Time_Turn_On_Total)
    {
        Sequence_On = true;
        First_Sequence_Image_X = 0;
    }



    while(1)
    {

        if(FTDI_On)FT_GetStatus(ftHandle,&RxBytes,&TxBytes,&EventDWord);

        if ((RxBytes >= 64) || !FTDI_On)
        {
        if(FTDI_On)
        {
            ftStatus = FT_Read(ftHandle,RxBuffer,RxBytes,&BytesReceived);
            if(BytesReceived != 64)printf("\n\n XXXXXXX MISSED FRAME XXXXXXXxx  BytesReceived %ld \n\n", BytesReceived  );
        }


        // write to xilinx stuff
            if((RxBytes == 64) || !FTDI_On)
            {
                New_1.Start_Delay_Timer();
                New_2.Start_Delay_Timer();
                New_3.Start_Delay_Timer();
                New_4.Start_Delay_Timer();
                New_5.Start_Delay_Timer();
                New_6.Start_Delay_Timer();
                New_7.Start_Delay_Timer();
                New_8.Start_Delay_Timer();
                New_9.Start_Delay_Timer();
                New_10.Start_Delay_Timer();
                New_11.Start_Delay_Timer();
                // check the program cycle time  (total interval is 33.3 ms)
                Program_Timer.End_Delay_Timer();
                Program_Timer.Start_Delay_Timer();
                // Check the loop time not including the tick from hardware
                Within_Loop_Timer.Start_Delay_Timer();
                loopcnt++;






                time (&time_time);
                time_X = localtime(&time_time);
                Current_Hour = time_X->tm_hour;
                Current_Minute = time_X->tm_min;
                Current_Second = time_X->tm_sec;
                Time_Current_Total = Current_Hour * 3600 + Current_Minute * 60 + Current_Second;



                Turn_On_Time =   (Time_Current_Total ==  Time_Turn_On_Total  ) ;
                Turn_On_Time_Trigger = (!Turn_On_Time_Delayed & Turn_On_Time);
                Turn_On_Time_Delayed = Turn_On_Time;


                Turn_Color_Time =   (Time_Current_Total ==  Time_Turn_Color_Total  ) ;
                Turn_Color_Time_Trigger = (!Turn_Color_Time_Delayed & Turn_Color_Time);
                Turn_Color_Time_Delayed = Turn_Color_Time;


                Turn_Off_Time =   (Time_Current_Total ==  Time_Turn_Off_Total  ) ;
                Turn_Off_Time_Trigger = (!Turn_Off_Time_Delayed & Turn_Off_Time);
                Turn_Off_Time_Delayed = Turn_Off_Time;



                if(Turn_On_Time_Trigger)
                {
                    Sequence_On = true;
                    First_Sequence_Image_X = 0;
                }
                else if(Turn_Color_Time_Trigger)
                {
                   Sequence_On = false;
                    New_Image_Selected = Night_Color;
                }
                else if(Turn_Off_Time_Trigger)
                {
                    Sequence_On = false;
                    New_Image_Selected = 0;
                }



                if(Sequence_On && !Sequence_On_Delayed)
                {

                    Sequence_Duration_Counter   = 0;  //
                    Current_Sequencer_Selection = First_Sequence_Image_X;  // which image
                    New_Sequenced_Image_Selected = true;
                }
                else if(Sequence_On)
                {
                    Duartion_Mod = Test_Mode ?   5. : Sequencer_Parameters[Current_Sequencer_Selection][Duration] ;
                    Sequence_Duration_Counter++;
                    if((Sequence_Duration_Counter/30.) >= Duartion_Mod)
                    {
                        Current_Sequencer_Selection++;
                        New_Sequenced_Image_Selected = true;
                        if(Current_Sequencer_Selection > Num_of_Sequencer_Image_Files_Read)Current_Sequencer_Selection = 4;
                    }
                }


                // look for change in Sequence Enabled
                Sequence_On_Delayed = Sequence_On;


                New_Keyboard_Image = ( ( New_Image_Selected < Num_of_Image_Files_Read) && ( New_Image_Selected > -1) );
                New_Sequenced_Image = (New_Sequenced_Image_Selected  &&  (Current_Sequencer_Selection < Num_of_Sequencer_Image_Files_Read) ) ;





                /************************************  IMAGE A STUFF  ***********************************/


                if (    (  New_Keyboard_Image || New_Sequenced_Image )  && (Current_A_Or_B == Image_B) )
                {

                  //  printf("\n made it to HERE1  \n"); // , Current_Sequencer_Selection);
                    if(New_Sequenced_Image_Selected)New_Image_A = Current_Sequencer_Selection;
                    else New_Image_A = New_Image_Selected;

                    if(cap_A.isOpened())cap_A.release();

                    strcpy(File1, Path);
                    strcat(File1, "Movies/");


                    if(New_Sequenced_Image_Selected)strcpy(CurFile,  Sequencr_File_Names[New_Image_A] ) ;
                    else strcpy(CurFile,  Image_File_Names[New_Image_A] ) ;

                    strcat(File1, CurFile);
                    strcat(File1,  ".mov" ) ;


                    if(New_Sequenced_Image_Selected)
                    {
                        Gain_A      = Sequencer_Parameters[New_Image_A][Gain_X];
                        Red_62_A    = Sequencer_Parameters[New_Image_A][Red_Val];
                        Green_62_A  = Sequencer_Parameters[New_Image_A][Green_Val];
                        Blue_62_A   = Sequencer_Parameters[New_Image_A][Blue_Val];
                        C_Gain_A   = Sequencer_Parameters[New_Image_A][Chroma_X];
                    }
                    else
                    {
                        Gain_A      = Image_Parameters[New_Image_A][Gain_X];
                        Red_62_A    = Image_Parameters[New_Image_A][Red_Val];
                        Green_62_A  = Image_Parameters[New_Image_A][Green_Val];
                        Blue_62_A   = Image_Parameters[New_Image_A][Blue_Val];
                        C_Gain_A   = Image_Parameters[New_Image_A][Chroma_X];
                    }

                    cap_A.open(File1);
                    // Check if capture opened successfully
                    if(!cap_A.isOpened()){
                    cout << "Error opening video stream or file  44444"   << endl;
                    return -1;
                    }

                    Fade_Direction = ToA;
                    New_Image_Selected = 1000;
                    New_Sequenced_Image_Selected = false;
                    Current_A_Or_B = Image_Fading;
                    Sequence_Duration_Counter = 0;
                }

                // 2.5 - 5 ms  BIG RANGE !!!!!
                // Capture frame-by-frame   transfer image into float buffer
                if(!Pause_A)cap_A >> img_in_A ; // img_in_1;  // have to cimage_proc_1_sampledapture at 8 bit
                if (img_in_A.empty())      // If the frame is empty, break immediately
                {
                    cout << "Error opening video stream or file  5555"   << endl;
                    break;
                }

                // loop the video file
                if (cap_A.get(CAP_PROP_POS_FRAMES) == (cap_A.get(CV_CAP_PROP_FRAME_COUNT)  ) )
                {
                    cap_A.set(CV_CAP_PROP_POS_FRAMES, 0);
                    // check the video loop time
                    Video_Loop_Timer.End_Delay_Timer();
                    Video_Loop_Timer.Start_Delay_Timer();
                    printf("\nVideo Loop Time %6.2f \n\n",Video_Loop_Timer.time_delay/1000);
                }

                New_1.End_Delay_Timer();



                if(Seam_Flip)Shift_Image_Horizontal(img_in_A, 512);   // Change_Seam(img_in_A, 1);

                // 8 bit IN  32 float OUT  Filter Gain and Black Level
                img_in_A.copyTo(img_in_A_U);  // UMat

                Process_Image_U(img_in_A_U, img_in_A_U, YUV_Gain_A, Filter_On_Off_A,
                            F_1p1_A, F_2p2_A,  F_3p3_A,  F_4p4_A,  Filter_3Taps_On_A,
                            Ones2x2_A,  Ones3x3_A,  Ones4x4_A,  Ones5x5_A,  Ones6x6_A,  Ones7x7_A,  Ones_On_A,
                            Gain_A, Black_Level_A, C_Gain_A ) ;

                New_2.End_Delay_Timer();
                img_in_A_U.copyTo(img_proc_A);  // convert back to Mat
                New_3.End_Delay_Timer();

                /************************************  IMAGE A STUFF DONE ***********************************/







                /************************************  IMAGE B STUFF   ***********************************/

                if (    (  New_Keyboard_Image || New_Sequenced_Image )  && (Current_A_Or_B == Image_A) )
                {

                    if(New_Sequenced_Image_Selected)New_Image_B = Current_Sequencer_Selection;
                    else New_Image_B = New_Image_Selected;

                    if(cap_B.isOpened())cap_B.release();

                    strcpy(File1, Path);
                    strcat(File1, "Movies/");

                    if(New_Sequenced_Image_Selected)strcpy(CurFile,  Sequencr_File_Names[New_Image_B] ) ;
                    else strcpy(CurFile,  Image_File_Names[New_Image_B] ) ;

                    strcat(File1, CurFile);
                    strcat(File1,  ".mov" ) ;


                    if(New_Sequenced_Image_Selected)
                    {
                        Gain_B      = Sequencer_Parameters[New_Image_B][Gain_X];
                        Red_62_B    = Sequencer_Parameters[New_Image_B][Red_Val];
                        Green_62_B  = Sequencer_Parameters[New_Image_B][Green_Val];
                        Blue_62_B   = Sequencer_Parameters[New_Image_B][Blue_Val];
                        C_Gain_B   = Sequencer_Parameters[New_Image_B][Chroma_X];
                    }
                    else
                    {
                        Gain_B      = Image_Parameters[New_Image_B][Gain_X];
                        Red_62_B    = Image_Parameters[New_Image_B][Red_Val];
                        Green_62_B  = Image_Parameters[New_Image_B][Green_Val];
                        Blue_62_B   = Image_Parameters[New_Image_B][Blue_Val];
                        C_Gain_B   = Image_Parameters[New_Image_B][Chroma_X];
                    }


                    cap_B.open(File1);

                    // Check if capture opened successfully
                    if(!cap_B.isOpened()){
                    cout << "Error opening video stream or file  44444"   << endl;
                    return -1;
                    }

                    Fade_Direction = ToB;
                    New_Image_Selected = 1000;
                    New_Sequenced_Image_Selected = false;
                    Current_A_Or_B = Image_Fading;
                    Sequence_Duration_Counter = 0;
                }


                // 2.5 - 5 ms  BIG RANGE !!!!!
                // Capture frame-by-frame   transfer image into float buffer
                if(!Pause_B)cap_B >> img_in_B ; // img_in_1;  // have to cimage_proc_1_sampledapture at 8 bit
                if (img_in_B.empty())      // If the frame is empty, break immediately
                {
                    cout << "Error opening video stream or file  5555"   << endl;
                    break;
                }

                // loop the video file
                if (cap_B.get(CAP_PROP_POS_FRAMES) == (cap_B.get(CV_CAP_PROP_FRAME_COUNT)  ) )
                {
                    cap_B.set(CV_CAP_PROP_POS_FRAMES, 0);
                    // check the video loop tim
                }

                New_1B.End_Delay_Timer();

                if(Seam_Flip)Shift_Image_Horizontal(img_in_B, 512);   // Change_Seam(img_in_A, 1);

                // 8 bit IN  32 float OUT  Filter Gain and Black Level
                img_in_B.copyTo(img_in_B_U);

                Process_Image_U(img_in_B_U, img_in_B_U, YUV_Gain_B, Filter_On_Off_B,
                            F_1p1_B, F_2p2_B,  F_3p3_B,  F_4p4_B,  Filter_3Taps_On_B,
                           Ones2x2_B,  Ones3x3_B,  Ones4x4_B,  Ones5x5_B,  Ones6x6_B,  Ones7x7_B,  Ones_On_B,
                            Gain_B, Black_Level_B, C_Gain_B ) ;

                New_2B.End_Delay_Timer();
                img_in_B_U.copyTo(img_proc_B);  // convert back to Mat
                New_3B.End_Delay_Timer();

                /************************************  IMAGE 2 STUFF DONE  ***********************************/







                /************************************  FADER  ***********************************/


                    Fade_Rate = Test_Mode ? .01 : .0035;

           //     if(Sequence_On)
           //     {
                    Fader_Main( Current_A_Or_B,  Fader_Coef, Fade_Direction,  Fade_Rate );
                    addWeighted( img_in_A_U, Fader_Coef, img_in_B_U, 1-Fader_Coef, 0.0, Mat_Sum_U);
                    Mat_Sum_U.copyTo(Mat_Sum);  // convert back to Mat


                    Red_62_Combined     =  (uint8_t) ( (Red_62_A * Fader_Coef)      +  (Red_62_B * (1-Fader_Coef) ) );
                    Green_62_Combined   =  (uint8_t) ( (Green_62_A * Fader_Coef)    +  (Green_62_B * (1-Fader_Coef) ) );
                    Blue_62_Combined    =  (uint8_t) ( (Blue_62_A * Fader_Coef)     +  (Blue_62_B * (1-Fader_Coef)  ) );
            //    }

                /************************************  FADER DONE  ***********************************/






                // for full size display
                Mat_Sum.convertTo(Mat_Sum_Display, CV_8UC3);

                // output gain
                Temp_Gain = Video_On ? Downstream_Gain : 0 ;
                Mat_Sum *= Temp_Gain ;

                // // for small output display
                resize(Mat_Sum, Mat_Sum_sampled, Size(), .33, .33, INTER_NEAREST);
                Mat_Sum_sampled.convertTo(Mat_Sum_sampled, CV_8UC3);




                /************************************  SUBSAMPLE AND ADD HEADERS AND DOWNLOAD  *********************/

                // convert to 16 bit for mapping and sending to Hardware
                Mat_Sum.convertTo(img_proc_u16_A, CV_16UC3,256);  // .35 ms

                // sub samples based on map and converts to RGBW
                // WOULD UMat speed this up ??
                //    Save_Samples_From_CSV_Map_To_Buffer_RGBW_Convert_U(img_proc_1_u16_U, Grab_Buffer_RGBW, Sample_Points, Num_Of_Samples_Per_Row);  // .31 ms
                Save_Samples_From_CSV_Map_To_Buffer_RGBW_Convert(img_proc_u16_A, Grab_Buffer_RGBW, Sample_Points, Num_Of_Samples_Per_Row);  // .31 ms


                // maps the image sub samples to the panel map
                Panel_Mapper(Grab_Buffer_RGBW, Map_Buffer_W_Gaps_RGBW, Panel_Map_W_Gaps, RGBW); // .21 ms


                // add headers to the final output
                //    Add_Headers_DMX(Map_Buffer_W_Gaps_RGBW, Enclosure_Info, Constellation_On, Lumen_Pulse_Upper_On);  // .003 ms




                Add_Headers(Map_Buffer_W_Gaps_RGBW, Enclosure_Info);

        //        uint8_t Ramp = (uint8_t)loopcnt  ;

            //    uint8_t Temp   =  (uint8_t) ( (loopcnt>>8) & 0x00000003 ) ;
//
    //            uint8_t R_Ramp = (Temp == 0) ? Ramp>>3 : 0;
     //           uint8_t G_Ramp = (Temp == 1) ? Ramp>>3 : 0;
        //        uint8_t B_Ramp = (Temp == 2) ? Ramp>>3 : 0;

                uint8_t shortloopcnt;
                shortloopcnt++;
                if(shortloopcnt >= 64)shortloopcnt = 0;

/*
                //      flashing testing
                uint8_t Red62   = (shortloopcnt > 32) ? 255 : 0;
                uint8_t Green62 = (shortloopcnt > 32) ? 255 : 0;
                uint8_t Blue62  = (shortloopcnt > 32) ? 255 : 0;

                uint8_t Red63   = 0x10;
                uint8_t Green63 = (shortloopcnt > 32) ? 255 : 0;
                uint8_t Blue63  = (shortloopcnt > 32) ? 255 : 0;

                uint8_t RedTRX   =  (shortloopcnt > 32) ? 255 : 0;
                uint8_t GreenTRX =  (shortloopcnt > 32) ? 255 : 0;
                uint8_t BlueTRX  =  0 ;


                uint16_t RedConstellation   = 0x0000;
                uint16_t GreenConstellation = 0x0000 ;
                uint16_t BlueConstellation  = 0x0000 ;
                uint16_t WhiteConstellation  = (shortloopcnt > 32) ? 0x8000 : 0;

                uint8_t Red6465   = (shortloopcnt > 32) ? 0xff : 0;
                uint8_t Green6465 = 0x00 ;
                uint8_t Blue6465  = 0x00 ;

*/


                uint8_t Red62   = Red_62_Combined;    // (shortloopcnt > 32) ? 255 : 0;
                uint8_t Green62 = Green_62_Combined;  //(shortloopcnt > 32) ? 255 : 0;
                uint8_t Blue62  = Blue_62_Combined;  // (shortloopcnt > 32) ? 255 : 0;

                uint8_t Red63   = Red_62_Combined;
                uint8_t Green63 = Green_62_Combined;
                uint8_t Blue63  = Blue_62_Combined;

                uint8_t Red6465   = Red_62_Combined;
                uint8_t Green6465 = Green_62_Combined;
                uint8_t Blue6465  = Blue_62_Combined ;

                uint8_t RedTRX   =  Red_62_Combined;
                uint8_t GreenTRX =  Green_62_Combined;
                uint8_t BlueTRX  =  Blue_62_Combined ;

                uint16_t RedConstellation   = 35 * Red_62_Combined;
                uint16_t GreenConstellation = 100 * Green_62_Combined ;
                uint16_t BlueConstellation  = 100 * Blue_62_Combined ;
                uint16_t WhiteConstellation  = 25;




      //          uint16_t RedConstellation   =   0 * 256;
      //          uint16_t GreenConstellation = 90  * 256;
      //          uint16_t BlueConstellation  = 120 * 256;
      //          uint16_t WhiteConstellation  = 0;





                Add_DMX(Map_Buffer_W_Gaps_RGBW, Enclosure_Info, Constellation_On, Lumen_Pulse_Upper_On, LP_62_On, LP_63_On, TRX_On,
                            RedConstellation, GreenConstellation, BlueConstellation, WhiteConstellation,
                            Red6465, Green6465, Blue6465,
                            Red62,Green62,Blue62,
                            Red63,Green63,Blue63,
                            RedTRX, GreenTRX, BlueTRX );


                New_4.End_Delay_Timer();

                // test
                // if(Grab == true)Grab_Test(  Grab_Buffer, Map_Buffer, Map_Buffer_W_Gaps, Map_Buffer_W_Gaps_RGBW, Grab );
                // Grab = false;

                New_5.End_Delay_Timer();

                ftStatus = FT_GetStatus(ftHandle,&RxBytes,&TxBytes,&EventDWord);

                if((ftStatus == FT_OK) && (TxBytes == 0))ftStatus = FT_Write(ftHandle, (char*)Map_Buffer_W_Gaps_RGBW, Buffer_W_Gaps_Size_RGBW_Bytes_Extra, &BytesWritten);

                New_6.End_Delay_Timer();

                /************************************  CAPTURE AND ADD HEADERS DONE ***********************************/



                A_or_B_File_Ext = (Fade_Direction == ToA)  ;

                if(Fade_Direction == ToA)  img_proc_A.convertTo(img_proc_A, CV_8UC3);
                else img_proc_B.convertTo(img_proc_B, CV_8UC3);
                Display_Mat_Select( "Preview", img_proc_A, img_proc_B,  A_or_B_File_Ext , 1, 20, 350);




                if(Points_Visible > 0)Add_Visible_Sample_Locations_From_CSV_Map_2(Mat_Sum_Display, Sample_Points, Num_Of_Samples_Per_Row, Points_Visible);

                Display_Mat("Final_Output",Mat_Sum_Display,20,20);

                New_7.End_Delay_Timer();


                Display_Mat("Final Output Small",Mat_Sum_sampled,1104,20);


                New_8.End_Delay_Timer();




                Display_Text_Mat("text window", text_window, 20, 680,
                    Pause_A,  Gain_A,   C_Gain_A ,   F_1p1_A,   F_2p2_A,   F_3p3_A,   F_4p4_A,   Ones2x2_A,   Ones3x3_A,   Ones4x4_A,   Ones5x5_A,   Ones6x6_A,   Ones7x7_A,
                    Pause_B,   Gain_B,   C_Gain_B ,   F_1p1_B,   F_2p2_B,   F_3p3_B,   F_4p4_B,   Ones2x2_B,   Ones3x3_B,   Ones4x4_B,   Ones5x5_B,   Ones6x6_B,   Ones7x7_B,
                    CurFile,   Downstream_Gain ,   Video_On, Fader_Coef,   Fade_Rate,  Current_A_Or_B,    A_or_B_File_Ext,
                    Test_Mode,   Sequence_On,  Current_Sequencer_Selection ,  Sequence_Duration_Counter ,    Duartion_Mod,
                    Constellation_On,   Lumen_Pulse_Upper_On,   LP_62_On,   LP_63_On,   TRX_On,  Red_62_Combined,  Green_62_Combined,  Blue_62_Combined,
                    Current_Hour,  Current_Minute,  Current_Second,   Hours_On,  Mins_On,   Hours_Off,  Mins_Off,   max_stored);



                Display_and_Fill_Upper_LP("upper_LP", upper_LP_window, 1104, 200, Red6465/2, Green6465/2, Blue6465/2);



                New_9.End_Delay_Timer();

                // Press  ESC on keyboard to exit etc                if(cnt == 4)printf("   VEC   %d  %d  %d\n",Pixel_Vec[0], Pixel_Vec[1], Pixel_Vec[2]);
                 c=(char)waitKey(1);  // part of openCV needs to be at least 1

                New_10.End_Delay_Timer();


                int dummy;

                if(Stop_Program)break;


              //   else if(c==27)break;

                else    KeyBoardInput(  c,

                A_or_B_File_Ext, New_Image_Selected, Points_Visible,  Downstream_Gain, Sequence_On,  Stop_Program, First_Sequence_Image_X,  Test_Mode,   Video_On,

                Pause_A,  Gain_A,  Black_Level_A,  C_Gain_A,

                img_On_A,   img_proc_On_A,  Show_Proc_A,

                Reset_All_Filters_A,    Ones_On_A,  Filter_3Taps_On_A,
                Ones2x2_A,       Ones3x3_A,  Ones4x4_A,  Ones5x5_A,  Ones6x6_A,  Ones7x7_A,
                F_1p1_A,           F_2p2_A,      F_3p3_A,      F_4p4_A,

                Pause_B,           Gain_B,           Black_Level_B,    C_Gain_B,

                img_On_B,          img_proc_On_B,     Show_Proc_B,

                Reset_All_Filters_B,    Ones_On_B,  Filter_3Taps_On_B,
                Ones2x2_B,       Ones3x3_B,  Ones4x4_B,  Ones5x5_B,  Ones6x6_B,  Ones7x7_B,
                F_1p1_B,           F_2p2_B,      F_3p3_B,      F_4p4_B,

                Constellation_On,  Lumen_Pulse_Upper_On, LP_62_On, LP_63_On, TRX_On, Seam_Flip
               );


                Within_Loop_Timer.End_Delay_Timer();

                // print debug stuff
                cnt++;
                if(cnt >= 66)cnt=0;

                New_11.End_Delay_Timer();

                if(cnt == 5)
                {
                    d1  = New_1.time_delay;
                    d2  = New_2.time_delay - New_1.time_delay;
                    d3  = New_3.time_delay - New_2.time_delay;
                    d4  = New_4.time_delay - New_3.time_delay;
                    d5  = New_5.time_delay - New_4.time_delay;
                    d6  = New_6.time_delay - New_5.time_delay;
                    d7  = New_7.time_delay - New_6.time_delay;
                    d8  = New_8.time_delay - New_7.time_delay;
                    d9  = New_9.time_delay - New_8.time_delay;
                    d10 = New_10.time_delay - New_9.time_delay;
                    d11  = New_11.time_delay - New_10.time_delay;
                    max_Within_Loop_Timer = Within_Loop_Timer.time_delay;
                }
                else if(Within_Loop_Timer.time_delay > max_Within_Loop_Timer)
                {
                    d1  = New_1.time_delay;
                    d2  = New_2.time_delay - New_1.time_delay;
                    d3  = New_3.time_delay - New_2.time_delay;
                    d4  = New_4.time_delay - New_3.time_delay;
                    d5  = New_5.time_delay - New_4.time_delay;
                    d6  = New_6.time_delay - New_5.time_delay;
                    d7  = New_7.time_delay - New_6.time_delay;
                    d8  = New_8.time_delay - New_7.time_delay;
                    d9  = New_9.time_delay - New_8.time_delay;
                    d10 = New_10.time_delay - New_9.time_delay;
                    d11  = New_11.time_delay - New_10.time_delay;
                    max_Within_Loop_Timer = Within_Loop_Timer.time_delay;
                }

                if(cnt == 4)
                {
                    printf("\n\n %.2f   %.1f    %.1f  %.1f  %.1f  %.1f  %.1f  %.1f  %.1f  %.1f  %.1f  %.1f  %.1f\n", Program_Timer.time_delay, max_Within_Loop_Timer, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11 );
                    max_stored = max_Within_Loop_Timer;
               //     printf("\n\n Show_Proc_B %d   img_On_B %d  G %f  B %f" ,  Show_Proc_B , img_On_B, Gain_B, Black_Level_B);
                }
            }
        }

    }

      // When everything done, release the video capture object
      cap_A.release();
      cap_B.release();

      // Closes all the frames
      destroyAllWindows();

      FT_Close(ftHandle); // !!

      return 0;
}




// misc things tried !!!!




    // pthread_t t1,t2;


/*
        for(int yy=0; (yy < 280); yy++)
            for(int xx=0; (xx < 1024); xx++)
            {
                image_proc_1_sampled.at<Vec3f>(Point(xx,yy)) =  img_proc_1.at<Vec3f>(Point(xx,yy)) ;
            }
*/




/*
	int err = pthread_create(&thread1, NULL, &threadFunc, NULL);
	// Check if thread is created sucessfuly
	if (err)
	{img_1_On
		std::cout << "Thread creation failed : " << strerror(err);
		return err;
	}
	else
		std::cout << "Thread Created with ID : " << thread1 << std::endl;
*/


         //        Alpha1.convertTo(Alpha1, CV_32FC3); //
         //       multiply(Alpha1, img_proc_2, img_proc_2);
        //        img_proc_2.convertTo(img_proc_2, -1, 1./255., 0);


                //  double resize to give approx building resolution
                // resize(img_proc_1, img_proc_1, Size(), 0.25, 0.2p5, INTER_LINEAR  );
                // resize(img_proc_1, img_proc_1, Size(), 4, 4, INTER_NEAREST);
                // display the filtered image

                // display the raw input image
                //resize(frame2, frame2, Size(), 0.5, 0.5, INTER_LINEAR  );
                //resize(frame2, frame2, Size(), 2, 2, INTER_NEAREST  );

/*
                // filter options -- faster to do the filters inline ???
                img_in_1.convertTo(img_proc_1, CV_32FC3);
                Filter_3Taps(img_proc_1, Filter_1p1, Filter_2p2, Filter_3p3, Filter_4p4, Filter_3Taps_On);
                Filter_Blurs(img_proc_1, Ones2x2, Ones3x3, Ones4x4, Ones5x5, Ones6x6, Ones7x7, Ones_On);
                img_proc_1.convertTo(img_proc_1, -1, gain, black_level);
*/

                // gamma curve check,
                //multiply(img_in_1F,img_in_1F,img_in_1F);


                // convert to floatw
          //      img_in_2.convertTo(img_proc_2, CV_32FC3);

                // filter options -- faster to do the filters inline ???
                // Filter_Combo(img_proc_2, Filter_On_Off, Filter_2p2, Filter_3p3, Filter_4p4);

         //       Filter_3Taps(img_proc_2, Filter_1p1, Filter_2p2, Filter_3p3, Filter_4p4, Filter_3Taps_On);
         //       Filter_Blurs(img_proc_2, Ones2x2, Ones3x3, Ones4x4, Ones5x5, Ones6x6, Ones7x7, Ones_On);

                //  contrast brightness
         //       float gain2 = 1.1;
         //       float black_level2 = -32;
         //       img_proc_2.convertTo(img_proc_2, -1, gain2, black_level2);
